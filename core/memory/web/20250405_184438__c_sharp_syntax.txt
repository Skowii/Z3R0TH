# ðŸ”— https://en.wikipedia.org/wiki/C_Sharp_syntax

Set of rules defining correctly structured programs for the C# programming language This article describes the syntax of the C# programming language. The features described are compatible with .NET Framework and Mono. Basics [ edit ] Identifier [ edit ] An identifier is the name of an element in the code. It can contain letters, digits and underscores ( _ ), and is case sensitive ( FOO is different from foo ). The language imposes the following restrictions on identifier names: They cannot start with a digit; They cannot start with a symbol, unless it is a keyword; They cannot contain more than 511 characters. Identifier names may be prefixed by an at sign ( @ ), but this is insignificant; @name is the same identifier as name . Microsoft has published naming conventions for identifiers in C#, which recommends the use of PascalCase for the names of types and most type members, and camelCase for variables and for private or internal fields.[1] However, these naming conventions are not enforced in the language. Keywords [ edit ] Keywords are predefined reserved words with special syntactic meaning.[2] The language has two types of keyword   contextual and reserved. The reserved keywords such as false or byte may only be used as keywords. The contextual keywords such as where or from are only treated as keywords in certain situations.[3] If an identifier is needed which would be the same as a reserved keyword, it may be prefixed by an at sign to distinguish it. For example, @out is interpreted as an identifier, whereas out as a keyword. This syntax facilitates reuse of .NET code written in other languages.[4] The following C# keywords are reserved words:[2] abstract as base bool break byte case catch char checked class const continue decimal default delegate do double else enum event explicit extern false finally fixed float for foreach goto if implicit in int interface internal is lock long namespace new null object operator out override params private protected public readonly ref return sbyte sealed short sizeof stackalloc static string struct switch this throw true try typeof uint ulong unchecked unsafe ushort using virtual void volatile while A contextual keyword is used to provide a specific meaning in the code, but it is not a reserved word in C#. Some contextual keywords, such as partial and where , have special meanings in multiple contexts. The following C# keywords are contextual:[5] add allows alias and ascending args async await by descending dynamic equals from get global group init into join let managed nameof nint not notnull nuint on or orderby partial record remove required select set unmanaged value var when where with yield Literals [ edit ] Integers [ 6 ] decimal 23456 , [ 0. . 9 ] + hexadecimal 0 xF5 , 0 x [ 0. . 9 , A .. F , a .. f ] + binary 0 b010110001101 , 0 b [ 0 , 1 ] + Floating-point values [ 7 ] float 23.5F , 23.5f ; 1.72 E3F , 1.72 E3f , 1.72 e3F , 1.72 e3f double 23.5 , 23.5D , 23.5d ; 1.72 E3 , 1.72 E3D , ... decimal 79228162514264337593543950335 m , - 0.0000000000000000000000000001 m , ... Characters [ 8 ] char 'a' , 'Z' , '\ u0231 ' , '\ x30 ' , ' ' Strings [ 9 ] string "Hello, world" "C:\\Windows\\" , @"C:\Windows\" [verbatim strings (preceded by @) may include line-break and carriage return characters] $"Hello, {name}!" Interpolated string. As a verbatim string: $ @"Hello, {name}!" ^ Strings are not null-terminated in C#, so null characters may appear anywhere in a string. Digit separators [ edit ] Starting in C# 7.0, the underscore symbol can be used to separate digits in number values for readability purposes. The compiler ignores these underscores.[6] int bin = 0 b1101_0010_1011_0100 ; int hex = 0 x2F_BB_4A_F1 ; int dec = 1 _000_500_954 ; double real = 1 _500 . 200 _2e - 1 _000 ; Generally, it may be put only between digit characters. It cannot be put at the beginning ( _121 ) or the end of the value ( 121_ or 121.05_ ), next to the decimal in floating point values ( 10_.0 ), next to the exponent character ( 1.1e_1 ), or next to the type specifier ( 10_f ). Variables [ edit ] Variables are identifiers associated with values. They are declared by writing the variable's type and name, and are optionally initialized in the same statement.[10][11] Declare int myInt ; // Declaring an uninitialized variable called 'myInt', of type 'int' Assigning int myInt ; // Declaring an uninitialized variable myInt = 35 ; // Assigning the variable a value Initialize int myInt = 35 ; // Declaring and initializing the variable Multiple variables of the same type can be declared and initialized in one statement. int a , b ; // Declaring multiple variables of the same type int a = 2 , b = 3 ; // Declaring and initializing multiple variables of the same type Local variable type inference [ edit ] This is a feature of C# 3.0. C# 3.0 introduced type inference, allowing the type specifier of a variable declaration to be replaced by the keyword var , if its actual type can be statically determined from the initializer. This reduces repetition, especially for types with multiple generic type-parameters, and adheres more closely to the DRY principle. var myChars = new char [] { 'A' , ' ' }; // or char[] myChars = new char[] {'A', ' '}; var myNums = new List < int > (); // or List<int> myNums = new List<int>(); Constants [ edit ] Constants are immutable values. const [ edit ] When declaring a local variable or a field with the const keyword as a prefix the value must be given when it is declared. After that it is locked and cannot change. They can either be declared in the context as a field or a local variable.[10] Constants are implicitly static. const double PI = 3.14 ; This shows both uses of the keyword. public class Foo { private const double X = 3 ; public Foo () { const int y = 2 ; } } readonly [ edit ] The readonly keyword does a similar thing to fields. Like fields marked as const they cannot change once initialized. The difference is that one can choose to initialize them in a constructor, or to a value that is not known until run-time.[12] This only works on fields. readonly fields can either be members of an instance or static class members. Code blocks [ edit ] Curly braces { ... } are used to signify a code block and a new scope. Class members and the body of a method are examples of what can live inside these braces in various contexts. Inside of method bodies, braces can be used to create new scopes: void DoSomething () { int a ; { int b ; a = 1 ; } a = 2 ; b = 3 ; // Will fail because the variable is declared in an inner scope. } Program structure [ edit ] A C# application consists of classes and their members. Classes and other types exist in namespaces but can also be nested inside other classes. Main method [ edit ] Whether it is a console or a graphical interface application, the program must have an entry point of some sort. The entry point of a C# application is the Main method. There can only be one declaration of this method, and it is a static method in a class. It usually returns void and is passed command-line arguments as an array of strings. static void Main ( string [] args ) // string[] args can be omitted if the program doesn't have any command-line arguments. { } The main method is also allowed to return an integer value if specified. static int Main ( string [] args ) { return 0 ; } Async Main [ edit ] This is a feature of C# 7.1. Asynchronous Tasks can be awaited in the Main method by declaring the method's return type as Task . static async Task Main ( string [] args ) { await DoWorkAsync ( 42 ); } All the combinations of Task , or Task<int>, and with, or without, the string[] args parameter are supported. Top-level statements [ edit ] This is a feature of C# 9.0. Similar to in scripting languages, top-level statements removes the ceremony of having to declare the Program class with a Main method. Instead, statements can be written directly in one specific file, and that file will be the entry point of the program. Code in other files will still have to be defined in classes. This was introduced to make C# less verbose, and thus more accessible for beginners to get started. using System ; Console . WriteLine ( "Hello World!" ); Types are declared after the statements, and will be automatically available from the statements above them. Namespaces [ edit ] Namespaces are a part of a type name and they are used to group and/or distinguish named entities from other ones. System . IO . DirectoryInfo // DirectoryInfo is in the System.IO-namespace A namespace is defined like this: namespace FooNamespace { // Members } A namespace can be put inside a namespace like this: namespace FooNamespace { // Members namespace BarNamespace { // Members } } It can also be done like this: namespace FooNamspace { // Members } namespace FooNamspace.BarNamespace { // Members } In C# 10 and later, namespaces can also be defined using file-scoped declarations by doing the following:[13] namespace FooNamespace ; // the brackets are omitted here in favor of a semicolon. using directive [ edit ] The using directive loads a specific namespace from a referenced assembly. It is usually placed in the top (or header) of a code file but it can be placed elsewhere if wanted, e.g. inside classes.[citation needed] using System ; using System.Collections ; The directive can also be used to define another name for an existing namespace or type. This is sometimes useful when names are too long and less readable. using Net = System . Net ; using DirInfo = System . IO . DirectoryInfo ; using static directive [ edit ] The using static directive loads the static members of a specified type into the current scope, making them accessible directly by the name of the member. using static System . Console ; WriteLine ( "Hello, World!" ); Operators [ edit ] Operator category Operators Arithmetic + , - , * , / , % Logical (boolean and bitwise) & , | , ^ , ! , ~ , && , || , true , false String concatenation + Increment, decrement ++ , -- Shift << , >> Relational (conditional) == , != , < , > , <= , >= Assignment = , += , -= , *= , /= , %= , &= , |= , ^= , <<= , >>= Member access . , ?. , ? [] Indexing [] Cast () Conditional (ternary) ? : Delegate concatenation and removal + , - Object creation new Type information as , is , sizeof , typeof Overflow exception control checked , unchecked Indirection and Address * , -> , [] , & Coalesce ?? Lambda expression => Operator overloading [ edit ] Some of the existing operators can be overloaded by writing an overload method. public static Foo operator + ( Foo foo , Bar bar ) { return new Foo ( foo . Value + bar . Value ); } These are the overloadable operators: Operators + , - , ! , ~ , ++ , -- , true , false Unary operators + , - , * , / , % , & , | , ^ , << , >> Binary operators == , != , < , > , <= , >= Comparison operators, must be overloaded in pairs Assignment operators ( += , *= etc.) are combinations of a binary operator and the assignment operator ( = ) and will be evaluated using the ordinary operators, which can be overloaded. ( etc.) are combinations of a binary operator and the assignment operator ( ) and will be evaluated using the ordinary operators, which can be overloaded. Cast operators ( ( ) ) cannot be overloaded, but it is possible to define conversion operators. ( ) cannot be overloaded, but it is possible to define conversion operators. Array indexing ( [ ] ) operator is not overloadable, but it is possible to define new indexers. Conversion operators [ edit ] The cast operator is not overloadable, but one can write a conversion operator method which lives in the target class. Conversion methods can define two varieties of operators, implicit and explicit conversion operators. The implicit operator will cast without specifying with the cast operator ( ( ) ) and the explicit operator requires it to be used. Implicit conversion operator class Foo { public int Value ; public static implicit operator Foo ( int value ) { return new Foo ( value ); } } // Implicit conversion Foo foo = 2 ; Explicit conversion operator class Foo { public int Value ; public static explicit operator Foo ( int value ) { return new Foo ( value ); } } // Explicit conversion Foo foo = ( Foo ) 2 ; as operator [ edit ] The as operator will attempt to do a silent cast to a given type. It will return the object as the new type if possible, and otherwise will return null. Stream stream = File . Open ( @"C:\Temp\data.dat" ); FileStream fstream = stream as FileStream ; // Will return an object. String str = stream as String ; // Will return null. Null coalesce operator [ edit ] This is a feature of C# 2.0. The following: return ifNotNullValue ?? otherwiseValue ; is shorthand for: return ifNotNullValue != null ? ifNotNullValue : otherwiseValue ; Meaning that if the content of variable ifNotNullValue is not null, that content will be returned, otherwise the content of variable otherwiseValue is returned. C# 8.0 introduces null-coalescing assignment, such that variable ??= otherwiseValue ; is equivalent to if ( variable is null ) variable = otherwiseValue ; Control structures [ edit ] C# inherits most of the control structures of C/C++ and also adds new ones like the foreach statement. Conditional structures [ edit ] These structures control the flow of the program through given conditions. if statement [ edit ] The if statement is entered when the given condition is true. Single-line case statements do not require block braces although it is mostly preferred by convention. Simple one-line statement: if ( i == 3 ) ... ; Multi-line with else-block (without any braces): if ( i == 2 ) ... else ... Recommended coding conventions for an if-statement. if ( i == 3 ) { ... } else if ( i == 2 ) { ... } else { ... } switch statement [ edit ] The switch construct serves as a filter for different values. Each value leads to a "case". It is not allowed to fall through case sections and therefore the keyword break is typically used to end a case. An unconditional return in a case section can also be used to end a case. See also how goto statement can be used to fall through from one case to the next. Many cases may lead to the same code though. The default case handles all the other cases not handled by the construct. switch ( ch ) { case 'A' : statement ; ... break ; case 'B' : statement ; break ; case 'C' : // A switch section can have multiple case labels. case 'D' : ... break ; default : ... break ; } Iteration structures [ edit ] Iteration statements are statements that are repeatedly executed when a given condition is evaluated as true. while loop [ edit ] while ( i == true ) { ... } do ... while loop [ edit ] do { } while ( i == true ); for loop [ edit ] The for loop consists of three parts: declaration, condition and counter expression. Any of them can be left out as they are optional. for ( int i = 0 ; i < 10 ; i ++ ) { ... } Is equivalent to this code represented with a while statement, except here the i variable is not local to the loop. int i = 0 ; while ( i < 10 ) { //... i ++ ; } foreach loop [ edit ] The foreach statement is derived from the for statement and makes use of a certain pattern described in C#'s language specification in order to obtain and use an enumerator of elements to iterate over. Each item in the given collection will be returned and reachable in the context of the code block. When the block has been executed the next item will be returned until there are no items remaining. foreach ( int i in intList ) { ... } Jump statements [ edit ] Jump statements are inherited from C/C++ and ultimately assembly languages through it. They simply represent the jump-instructions of an assembly language that controls the flow of a program. Labels and goto statement [ edit ] Labels are given points in code that can be jumped to by using the goto statement. start : ....... goto start ; Note that the label need not be positioned after the goto statement; it may be before it in the source file. The goto statement can be used in switch statements to jump from one case to another or to fall through from one case to the next. switch ( n ) { case 1 : Console . WriteLine ( "Case 1" ); break ; case 2 : Console . WriteLine ( "Case 2" ); goto case 1 ; case 3 : Console . WriteLine ( "Case 3" ); case 4 : // Compilation will fail here as cases cannot fall through in C#. Console . WriteLine ( "Case 4" ); goto default ; // This is the correct way to fall through to the next case. case 5 : // Multiple labels for the same code are OK case 6 : default : Console . WriteLine ( "Default" ); break ; // Even default must not reach the end point } break statement [ edit ] The break statement breaks out of the closest loop or switch statement. Execution continues in the statement after the terminated statement, if any. int e = 10 ; for ( int i = 0 ; i < e ; i ++ ) { while ( true ) { break ; } // Will break to this point. } continue statement [ edit ] The continue statement discontinues the current iteration of the current control statement and begins the next iteration. int ch ; while (( ch = Console . Read ()) != - 1 ) { if ( ch == ' ' ) continue ; // Skips the rest of the while-loop // Rest of the while-loop ... } The while loop in the code above reads characters by calling GetChar() , skipping the statements in the body of the loop if the characters are spaces. Exception handling [ edit ] Runtime exception handling method in C# is inherited from Java and C++. The base class library has a class called System.Exception from which all other exception classes are derived. An Exception -object contains all the information about a specific exception and also the inner exceptions that were caused. Programmers may define their own exceptions by deriving from the Exception class. An exception can be thrown this way: throw new NotImplementedException (); try ... catch ... finally statements [ edit ] Exceptions are managed within try ... catch blocks. try { // Statements which may throw exceptions ... } catch ( Exception ex ) { // Exception caught and handled here ... } finally { // Statements always executed after the try/catch blocks ... } The statements within the try block are executed, and if any of them throws an exception, execution of the block is discontinued and the exception is handled by the catch block. There may be multiple catch blocks, in which case the first block with an exception variable whose type matches the type of the thrown exception is executed. If no catch block matches the type of the thrown exception, the execution of the outer block (or method) containing the try ... catch statement is discontinued, and the exception is passed up and outside the containing block or method. The exception is propagated upwards through the call stack until a matching catch block is found within one of the currently active methods. If the exception propagates all the way up to the top-most Main() method without a matching catch block being found, the entire program is terminated and a textual description of the exception is written to the standard output stream. The statements within the finally block are always executed after the try and catch blocks, whether or not an exception was thrown. Such blocks are useful for providing clean-up code. Either a catch block, a finally block, or both, must follow the try block. Types [ edit ] C# is a statically typed language like C and C++. That means that every variable and constant gets a fixed type when it is being declared. There are two kinds of types: value types and reference types. Value types [ edit ] Instances of value types reside on the stack, i.e. they are bound to their variables. If one declares a variable for a value type the memory gets allocated directly. If the variable gets out of scope the object is destroyed with it. Structures [ edit ] Structures are more commonly known as structs. Structs are user-defined value types that are declared using the struct keyword. They are very similar to classes but are more suitable for lightweight types. Some important syntactical differences between a class and a struct are presented later in this article. struct Foo { ... } The primitive data types are all structs. Pre-defined types [ edit ] These are the primitive datatypes. Primitive types Type name BCL equivalent Value Range Size Default value sbyte System . SByte integer  128 through +127 8-bit (1-byte) 0 short System . Int16 integer  32,768 through +32,767 16-bit (2-byte) 0 int System . Int32 integer  2,147,483,648 through +2,147,483,647 32-bit (4-byte) 0 long System . Int64 integer  9,223,372,036,854,775,808 through +9,223,372,036,854,775,807 64-bit (8-byte) 0 byte System . Byte unsigned integer 0 through 255 8-bit (1-byte) 0 ushort System . UInt16 unsigned integer 0 through 65,535 16-bit (2-byte) 0 uint System . UInt32 unsigned integer 0 through 4,294,967,295 32-bit (4-byte) 0 ulong System . UInt64 unsigned integer 0 through 18,446,744,073,709,551,615 64-bit (8-byte) 0 decimal System . Decimal signed decimal number  79,228,162,514,264,337,593,543,950,335 through +79,228,162,514,264,337,593,543,950,335 128-bit (16-byte) 0.0 float System . Single floating point number  1.401298E 45 through  3.402823E+38 32-bit (4-byte) 0.0 double System . Double floating point number  4.94065645841246E 324 through  1.79769313486232E+308 64-bit (8-byte) 0.0 bool System . Boolean Boolean true or false 8-bit (1-byte) false char System . Char single Unicode character '\ u0000 ' through '\ uFFFF ' 16-bit (2-byte) '\ u0000 ' Note: string ( System.String ) is not a struct and is not a primitive type. Enumerations [ edit ] Enumerated types (declared with enum ) are named values representing integer values. enum Season { Winter = 0 , Spring = 1 , Summer = 2 , Autumn = 3 , Fall = Autumn // Autumn is called Fall in American English. } Enum variables are initialized by default to zero. They can be assigned or initialized to the named values defined by the enumeration type. Season season ; season = Season . Spring ; Enum type variables are integer values. Addition and subtraction between variables of the same type is allowed without any specific cast but multiplication and division is somewhat more risky and requires an explicit cast. Casts are also required for converting enum variables to and from integer types. However, the cast will not throw an exception if the value is not specified by the type definition. season = ( Season ) 2 ; // cast 2 to an enum-value of type Season. season = season + 1 ; // Adds 1 to the value. season = season + season2 ; // Adding the values of two enum variables. int value = ( int ) season ; // Casting enum-value to integer value. season ++ ; // Season.Spring (1) becomes Season.Summer (2). season -- ; // Season.Summer (2) becomes Season.Spring (1). Values can be combined using the bitwise-OR operator | . Color myColors = Color . Green | Color . Yellow | Color . Blue ; Reference types [ edit ] Variables created for reference types are typed managed references. When the constructor is called, an object is created on the heap and a reference is assigned to the variable. When a variable of an object goes out of scope the reference is broken and when there are no references left the object gets marked as garbage. The garbage collector will then soon collect and destroy it. A reference variable is null when it does not reference any object. Arrays [ edit ] An array type is a reference type that refers to a space containing one or more elements of a certain type. All array types derive from a common base class, System.Array . Each element is referenced by its index just like in C++ and Java. An array in C# is what would be called a dynamic array in C++. int [] numbers = new int [ 2 ]; numbers [ 0 ] = 2 ; numbers [ 1 ] = 5 ; int x = numbers [ 0 ]; Initializers [ edit ] Array initializers provide convenient syntax for initialization of arrays. // Long syntax int [] numbers = new int [ 5 ]{ 20 , 1 , 42 , 15 , 34 }; // Short syntax int [] numbers2 = { 20 , 1 , 42 , 15 , 34 }; // Inferred syntax var numbers3 = new [] { 20 , 1 , 42 , 15 , 34 }; Multi-dimensional arrays [ edit ] Arrays can have more than one dimension, for example 2 dimensions to represent a grid. int [,] numbers = new int [ 3 , 3 ]; numbers [ 1 , 2 ] = 2 ; int [,] numbers2 = new int [ 3 , 3 ] { { 2 , 3 , 2 }, { 1 , 2 , 6 }, { 2 , 4 , 5 } }; See also Classes [ edit ] Classes are self-describing user-defined reference types. Essentially all types in the .NET Framework are classes, including structs and enums, that are compiler generated classes. Class members are private by default, but can be declared as public to be visible outside of the class or protected to be visible by any descendants of the class. Strings [ edit ] The System.String class, or simply string , represents an immutable sequence of unicode characters ( char ). Actions performed on a string will always return a new string. string text = "Hello World!" ; string substr = text . Substring ( 0 , 5 ); string [] parts = text . Split ( new char []{ ' ' }); The System.StringBuilder class can be used when a mutable "string" is wanted. var sb = new StringBuilder (); sb . Append ( 'H' ); sb . Append ( "el" ); sb . AppendLine ( "lo!" ); Interface [ edit ] Interfaces are data structures that contain member definitions with no actual implementation. A variable of an interface type is a reference to an instance of a class which implements this interface. See #Interfaces. Delegates [ edit ] C# provides type-safe object-oriented function pointers in the form of delegates. class Program { // Delegate type: delegate int Operation ( int a , int b ); static int Add ( int i1 , int i2 ) { return i1 + i2 ; } static int Sub ( int i1 , int i2 ) { return i1 - i2 ; } static void Main () { // Instantiate the delegate and assign the method to it. Operation op = Add ; // Call the method that the delegate points to. int result1 = op ( 2 , 3 ); // 5 op = Sub ; int result2 = op ( 10 , 2 ); // 8 } } Initializing the delegate with an anonymous method. addition = delegate ( int a , int b ) { return a + b ; }; Initializing the delegate with lambda expression. addition = ( a , b ) => a + b ; Events [ edit ] Events are pointers that can point to multiple methods. More exactly they bind method pointers to one identifier. This can therefore be seen as an extension to delegates. They are typically used as triggers in UI development. The form used in C# and the rest of the Common Language Infrastructure is based on that in the classic Visual Basic. delegate void MouseEventHandler ( object sender , MouseEventArgs e ); public class Button : System . Windows . Controls . Control { private event MouseEventHandler _onClick ; /* Imaginary trigger function */ void Click () { _onClick ( this , new MouseEventArgs ( data )); } } An event requires an accompanied event handler that is made from a special delegate that in a platform specific library like in Windows Presentation Foundation and Windows Forms usually takes two parameters: sender and the event arguments. The type of the event argument-object derive from the EventArgs class that is a part of the CLI base library. Once declared in its class the only way of invoking the event is from inside of the owner. A listener method may be implemented outside to be triggered when the event is fired. public class MainWindow : System . Windows . Controls . Window { private Button _button1 ; public MainWindow () { _button1 = new Button (); _button1 . Text = "Click me!" ; /* Subscribe to the event */ _button1 . ClickEvent += Button1_OnClick ; /* Alternate syntax that is considered old: _button1.MouseClick += new MouseEventHandler(Button1_OnClick); */ } protected void Button1_OnClick ( object sender , MouseEventArgs e ) { MessageBox . Show ( "Clicked!" ); } } Custom event implementation is also possible: private EventHandler _clickHandles = ( s , e ) => { }; public event EventHandler Click { add { // Some code to run when handler is added... ... _clickHandles += value ; } remove { // Some code to run when handler is removed... ... _clickHandles -= value ; } } See also Nullable types [ edit ] This is a feature of C# 2.0. Nullable types were introduced in C# 2.0 firstly to enable value types to be null (useful when working with a database). int? n = 2 ; n = null ; Console . WriteLine ( n . HasValue ); In reality this is the same as using the Nullable<T> struct. Nullable < int > n = 2 ; n = null ; Console . WriteLine ( n . HasValue ); Pointers [ edit ] C# has and allows pointers to selected types (some primitives, enums, strings, pointers, and even arrays and structs if they contain only types that can be pointed[14]) in unsafe context: methods and codeblock marked unsafe . These are syntactically the same as pointers in C and C++. However, runtime-checking is disabled inside unsafe blocks. static void Main ( string [] args ) { unsafe { int a = 2 ; int * b = & a ; Console . WriteLine ( "Address of a: {0}. Value: {1}" , ( int ) & a , a ); Console . WriteLine ( "Address of b: {0}. Value: {1}. Value of *b: {2}" , ( int ) & b , ( int ) b , * b ); // Will output something like: // Address of a: 71953600. Value: 2 // Address of b: 71953596. Value: 71953600. Value of *b: 2 } } Structs are required only to be pure structs with no members of a managed reference type, e.g. a string or any other class. public struct MyStruct { public char Character ; public int Integer ; } public struct MyContainerStruct { public byte Byte ; public MyStruct MyStruct ; } In use: MyContainerStruct x ; MyContainerStruct * ptr = & x ; byte value = ptr -> Byte ; Dynamic [ edit ] Type dynamic is a feature that enables dynamic runtime lookup to C# in a static manner. Dynamic denotes a variable with an object with a type that is resolved at runtime, as opposed to compile-time, as normally is done. This feature takes advantage of the Dynamic Language Runtime (DLR) and has been designed specifically with the goal of interoperation with dynamically typed languages like IronPython and IronRuby (Implementations of Python and Ruby for .NET). Dynamic-support also eases interoperation with COM objects. dynamic x = new Foo (); x . DoSomething (); // Will compile and resolved at runtime. An exception will be thrown if invalid. Anonymous types [ edit ] This is a feature of C# 3.0. Anonymous types are nameless classes that are generated by the compiler. They are only consumable and yet very useful in a scenario like where one has a LINQ query which returns an object on select and one just wants to return some specific values. Then, define an anonymous type containing auto-generated read-only fields for the values. When instantiating another anonymous type declaration with the same signature the type is automatically inferred by the compiler. var carl = new { Name = "Carl" , Age = 35 }; // Name of the type is only known by the compiler. var mary = new { Name = "Mary" , Age = 22 }; // Same type as the expression above Boxing and unboxing [ edit ] Boxing is the operation of converting a value of a value type into a value of a corresponding reference type.[15] Boxing in C# is implicit. Unboxing is the operation of converting a value of a reference type (previously boxed) into a value of a value type.[15] Unboxing in C# requires an explicit type cast. Example: int foo = 42 ; // Value type. object bar = foo ; // foo is boxed to bar. int foo2 = ( int ) bar ; // Unboxed back to value type. Object-oriented programming (OOP) [ edit ] C# has direct support for object-oriented programming. Objects [ edit ] An object is created with the type as a template and is called an instance of that particular type. In C#, objects are either references or values. No further syntactical distinction is made between those in code. Object class [ edit ] All types, even value types in their boxed form, implicitly inherit from the System.Object class, the ultimate base class of all objects. This class contains the most common methods shared by all objects. Some of these are virtual and can be overridden. Classes inherit System.Object either directly or indirectly through another base class. Members Some of the members of the Object class: Equals - Supports comparisons between objects. - Supports comparisons between objects. Finalize - Performs cleanup operations before an object is automatically reclaimed. (Default destructor) - Performs cleanup operations before an object is automatically reclaimed. (Default destructor) GetHashCode - Gets the number corresponding to the value of the object to support the use of a hash table. - Gets the number corresponding to the value of the object to support the use of a hash table. GetType - Gets the Type of the current instance. - Gets the Type of the current instance. ToString - Creates a human-readable text string that describes an instance of the class. Usually it returns the name of the type. Classes [ edit ] Classes are fundamentals of an object-oriented language such as C#. They serve as a template for objects. They contain members that store and manipulate data in a real-life like way. Differences between classes and structs [ edit ] Although classes and structures are similar in both the way they are declared and how they are used, there are some significant differences. Classes are reference types and structs are value types. A structure is allocated on the stack when it is declared and the variable is bound to its address. It directly contains the value. Classes are different because the memory is allocated as objects on the heap. Variables are rather managed pointers on the stack which point to the objects. They are references. Structures differ from classes in several other ways. For example, while both offer an implicit default constructor which takes no arguments, one cannot redefine it for structs. Explicitly defining a differently-parametrized constructor will suppress the implicit default constructor in classes, but not in structs. All fields of a struct must be initialized in those kinds of constructors. Structs do not have finalizers and cannot inherit from another class like classes do. Implicitly, they are sealed and inherit from System.ValueType (which inherits from System.Object ). Structs are more suitable for smaller amounts of data. This is a short summary of the differences: Default constructor Finalizer Member initialization Inheritance Classes not required (auto generated) [ a ] yes not required yes (if base class is not sealed ) Structs required (auto generated) [ b ] no required not supported ^ Generated only if no other constructor was provided ^ Always auto-generated, and cannot be written by the programmer Declaration [ edit ] A class is declared like this: class Foo { // Member declarations } Partial class [ edit ] This is a feature of C# 2.0. A partial class is a class declaration whose code is divided into separate files. The different parts of a partial class must be marked with keyword partial . // File1.cs partial class Foo { ... } // File2.cs partial class Foo { ... } The usual reason for using partial classes is to split some class into a programmer-maintained and a tool-maintained part, i.e. some code is automatically generated by a user-interface designing tool or something alike. Initialization [ edit ] Before one can use the members of the class, initialize the variable with a reference to an object. To create it, call the appropriate constructor using the new keyword. It has the same name as the class. var foo = new Foo (); For structs it is optional to explicitly call a constructor because the default one is called automatically. It is just needed to declare it and it gets initialized with standard values. Object initializers [ edit ] This is a feature of C# 3.0. Provides a more convenient way of initializing public fields and properties of an object. Constructor calls are optional when there is a default constructor. var person = new Person { Name = "John Doe" , Age = 39 }; // Equal to var person = new Person (); person . Name = "John Doe" ; person . Age = 39 ; Collection initializers [ edit ] This is a feature of C# 3.0. Collection initializers give an array-like syntax for initializing collections. The compiler will simply generate calls to the Add-method. This works for classes that implement the interface ICollection . var list = new List < int > { 2 , 5 , 6 , 6 }; // Equal to var list = new List < int > (); list . Add ( 2 ); list . Add ( 5 ); list . Add ( 6 ); list . Add ( 6 ); Accessing members [ edit ] Members of an instance and static members of a class are accessed using the . operator. Accessing an instance member Instance members can be accessed through the name of a variable. string foo = "Hello" ; string fooUpper = foo . ToUpper (); Accessing a static class member Static members are accessed by using the name of the class or other type. int r = string . Compare ( foo , fooUpper ); Accessing a member through a pointer In unsafe code, members of a value (struct type) referenced by a pointer are accessed with the -> operator just like in C and C++. POINT p ; p . X = 2 ; p . Y = 6 ; POINT * ptr = & p ; ptr -> Y = 4 ; Modifiers [ edit ] Modifiers are keywords used to modify declarations of types and type members. Most notably there is a sub-group containing the access modifiers. Class modifiers [ edit ] abstract - Specifies that a class only serves as a base class. It must be implemented in an inheriting class. A precondition for allowing the class to have abstract methods. - Specifies that a class only serves as a base class. It must be implemented in an inheriting class. A precondition for allowing the class to have abstract methods. sealed - Specifies that a class cannot be inherited. Class member modifiers [ edit ] abstract - Declares a method to be available in all derived non-abstract classes. - Declares a method to be available in all derived non-abstract classes. const - Specifies that a variable is a constant value that has to be initialized when it gets declared. - Specifies that a variable is a constant value that has to be initialized when it gets declared. event - Declares an event. - Declares an event. extern - Specifies that a method signature without a body uses a DLL-import. - Specifies that a method signature without a body uses a DLL-import. override - Specifies that a method or property declaration is an override of a virtual member or an implementation of a member of an abstract class. - Specifies that a method or property declaration is an override of a virtual member or an implementation of a member of an abstract class. readonly - Declares a field that can only be assigned values as part of the declaration or in a constructor in the same class. - Declares a field that can only be assigned values as part of the declaration or in a constructor in the same class. unsafe - Specifies an unsafe context, which allows the use of pointers. - Specifies an unsafe context, which allows the use of pointers. virtual - Specifies that a method or property declaration can be overridden by a derived class. - Specifies that a method or property declaration can be overridden by a derived class. volatile - Specifies a field which may be modified by an external process and prevents an optimizing compiler from making guesses about the persistence of the current value of the field. static modifier [ edit ] The static modifier states that a member belongs to the class and not to a specific object. Classes marked static are only allowed to contain static members. Static members are sometimes referred to as class members since they apply to the class as a whole and not to its instances. public class Foo { public static void Something () { ... } } // Calling the class method. Foo . Something (); Access modifiers [ edit ] The access modifiers, or inheritance modifiers, set the accessibility of classes, methods, and other members. Something marked public can be reached from anywhere. private members can only be accessed from inside of the class they are declared in and will be hidden when inherited. Members with the protected modifier will be private , but accessible when inherited. internal classes and members will only be accessible from the inside of the declaring assembly. Classes and structs are implicitly internal and members are implicitly private if they do not have an access modifier. public class Foo { public int Do () { return 0 ; } public class Bar { } } This table defines where the access modifiers can be used. Unnested types Members (incl. nested types) Accessible to public yes yes all protected internal no yes same class, derived classes, and everything in the same assembly protected no yes same class and derived classes internal yes (default) yes everything in the same assembly private protected no yes same class, and derived classes in the same assembly private no yes (default) same class Constructors [ edit ] A constructor is a special method that is called automatically when an object is created. Its purpose is to initialize the members of the object. Constructors have the same name as the class and do not return anything explicitly. Implicitly, they will return the newly created object when called via the new operator. They may take parameters like any other method. The parameter-less constructor is special because it can be specified as a necessary constraint for a generic type parameter. class Foo { Foo () { ... } } Constructors can be public , private , protected or internal . Destructor [ edit ] The destructor is called when the object is being collected by the garbage collector to perform some manual clean-up. There is a default destructor method called finalize that can be overridden by declaring one. The syntax is similar to the one of constructors. The difference is that the name is preceded by a ~ and it cannot contain any parameters. There cannot be more than one destructor. class Foo { ... ~ Foo () { ... } } Finalizers are always private . Methods [ edit ] Like in C and C++ there are functions that group reusable code. The main difference is that functions, just like in Java, have to reside inside of a class. A function is therefore called a method. A method has a return value, a name and usually some parameters initialized when it is called with some arguments. It can either belong to an instance of a class or be a static member. class Foo { int Bar ( int a , int b ) { return a % b ; } } A method is called using . notation on a specific variable, or as in the case of static methods, the name of a type. Foo foo = new Foo (); int r = foo . Bar ( 7 , 2 ); Console . WriteLine ( r ); ref and out parameters [ edit ] One can explicitly make arguments be passed by reference when calling a method with parameters preceded by keywords ref or out . These managed pointers come in handy when passing variables that one wants to be modified inside the method by reference. The main difference between the two is that an out parameter must have been assigned within the method by the time the method returns. ref may or may not assign a new value, but the parameter variable has to be initialized before calling the function. void PassRef ( ref int x ) { if ( x == 2 ) x = 10 ; } int Z = 7 ; PassRef ( ref Z ); void PassOut ( out int x ) { x = 2 ; } int Q ; PassOut ( out Q ); Optional parameters [ edit ] This is a feature of C# 4.0. C# 4.0 introduces optional parameters with default values as seen in C++. For example: void Increment ( ref int x , int dx = 1 ) { x += dx ; } int x = 0 ; Increment ( ref x ); // dx takes the default value of 1 Increment ( ref x , 2 ); // dx takes the value 2 In addition, to complement optional parameters, it is possible to explicitly specify parameter names in method calls, allowing to selectively pass any given subset of optional parameters for a method. The only restriction is that named parameters must be placed after the unnamed parameters. Parameter names can be specified for both optional and required parameters, and can be used to improve readability or arbitrarily reorder arguments in a call. For example: Stream OpenFile ( string name , FileMode mode = FileMode . Open , FileAccess access = FileAccess . Read ) { ... } OpenFile ( "file.txt" ); // use default values for both "mode" and "access" OpenFile ( "file.txt" , mode : FileMode . Create ); // use default value for "access" OpenFile ( "file.txt" , access : FileAccess . Read ); // use default value for "mode" OpenFile ( name : "file.txt" , access : FileAccess . Read , mode : FileMode . Create ); // name all parameters for extra readability, // and use order different from method declaration Optional parameters make interoperating with COM easier. Previously, C# had to pass in every parameter in the method of the COM component, even those that are optional. For example: object fileName = "Test.docx" ; object missing = System . Reflection . Missing . Value ; doc . SaveAs ( ref fileName , ref missing , ref missing , ref missing , ref missing , ref missing , ref missing , ref missing , ref missing , ref missing , ref missing , ref missing , ref missing , ref missing , ref missing , ref missing ); console . writeline ( "File saved successfully" ); With support for optional parameters, the code can be shortened as doc . SaveAs ( ref fileName ); extern [ edit ] A feature of C# is the ability to call native code. A method signature is simply declared without a body and is marked as extern . The DllImport attribute also needs to be added to reference the desired DLL file. [DllImport("win32.dll")] static extern double Pow ( double a , double b ); Fields [ edit ] Fields, or instance variables, can be declared inside the class body to store data. class Foo { double foo ; } Fields can be initialized directly when declared (unless declared in struct). class Foo { double foo = 2.3 ; } Modifiers for fields: const - Makes the field a constant. - Makes the field a constant. private - Makes the field private (default). - Makes the field private (default). protected - Makes the field protected. - Makes the field protected. public - Makes the field public. - Makes the field public. readonly - Allows the field to be initialized only once in a constructor. - Allows the field to be initialized only once in a constructor. static - Makes the field a static member, i.e. a class variable. Properties [ edit ] Properties bring field-like syntax and combine them with the power of methods. A property can have two accessors: get and set . public class Person { private string _name ; string Name { get { return _name ; } set { _name = value ; } } } // Using a property var person = new Person (); person . Name = "Robert" ; Modifiers for properties: private - Makes the property private (default). - Makes the property private (default). protected - Makes the property protected. - Makes the property protected. public - Makes the property public. - Makes the property public. static - Makes the property a static member. Modifiers for property accessors: private - Makes the accessor private. - Makes the accessor private. protected - Makes the accessor protected. - Makes the accessor protected. public - Makes the accessor public. The default modifiers for the accessors are inherited from the property. Note that the accessor's modifiers can only be equal or more restrictive than the property's modifier. Automatic properties [ edit ] This is a feature of C# 3.0. A feature of C# 3.0 is auto-implemented properties. Define accessors without bodies and the compiler will generate a backing field and the necessary code for the accessors. public double Width { get ; private set ; } Indexers [ edit ] Indexers add array-like indexing capabilities to objects. They are implemented in a way similar to properties. internal class IntList { private int [] _items ; int this [ int index ] { get { return _items [ index ]; } set { _items [ index ] = value ; } } } // Using an indexer var list = new IntList (); list [ 2 ] = 2 ; Inheritance [ edit ] Classes in C# may only inherit from one class. A class may derive from any class that is not marked as sealed . class A { } class B : A { } virtual [ edit ] Methods marked virtual provide an implementation, but they can be overridden by the inheritors by using the override keyword. The implementation is chosen by the actual type of the object and not the type of the variable. class Operation { public virtual int Do () { return 0 ; } } class NewOperation : Operation { public override int Do () { return 1 ; } } new [ edit ] When overloading a non-virtual method with another signature, the keyword new may be used. The used method will be chosen by the type of the variable instead of the actual type of the object. class Operation { public int Do () { return 0 ; } } class NewOperation : Operation { public new double Do () { return 4.0 ; } } This demonstrates the case: var operation = new NewOperation (); // Will call "double Do()" in NewOperation double d = operation . Do (); Operation operation_ = operation ; // Will call "int Do()" in Operation int i = operation_ . Do (); abstract [ edit ] Abstract classes are classes that only serve as templates and one cannot initialize an object of that type. Otherwise, it is just like an ordinary class. There may be abstract members too. Abstract members are members of abstract classes that do not have any implementation. They must be overridden by any non-abstract class that inherits the member. abstract class Mammal { public abstract void Walk (); } class Human : Mammal { public override void Walk () { } ... } sealed [ edit ] The sealed modifier can be combined with the others as an optional modifier for classes to make them uninheritable, or for methods to disallow overriding them in derived classes. internal sealed class Foo { //... } public class Bar { public virtual void Action () { //... } } public class Baz : Bar { public sealed override void Action () { //... } } Interfaces [ edit ] Interfaces are data structures that contain member definitions and not actual implementation. They are useful when one wants to define a contract between members in different types that have different implementations. One can declare definitions for methods, properties, and indexers. Interface members are implicitly public. An interface can either be implicitly or explicitly implemented. interface IBinaryOperation { double A { get ; set ; } double B { get ; set ; } double GetResult (); } Implementing an interface [ edit ] An interface is implemented by a class or extended by another interface in the same way a class is derived from another class using the : notation. Implicit implementation When implicitly implementing an interface the members of the interface have to be public . public class Adder : IBinaryOperation { public double A { get ; set ; } public double B { get ; set ; } public double GetResult () { return A + B ; } } public class Multiplier : IBinaryOperation { public double A { get ; set ; } public double B { get ; set ; } public double GetResult () { return A * B ; } } In use: IBinaryOperation op = null ; double result ; // Adder implements the interface IBinaryOperation. op = new Adder (); op . A = 2 ; op . B = 3 ; result = op . GetResult (); // 5 // Multiplier also implements the interface. op = new Multiplier (); op . A = 5 ; op . B = 4 ; result = op . GetResult (); // 20 Explicit implementation One can also explicitly implement members. The members of the interface that are explicitly implemented by a class are accessible only when the object is handled as the interface type. public class Adder : IBinaryOperation { double IBinaryOperation . A { get ; set ; } double IBinaryOperation . B { get ; set ; } double IBinaryOperation . GetResult () { return (( IBinaryOperation ) this ). A + (( IBinaryOperation ) this ). B ; } } In use: Adder add = new Adder (); // These members are not accessible: // add.A = 2; // add.B = 3; // double result = add.GetResult(); // Cast to the interface type to access them: IBinaryOperation add2 = add ; add2 . A = 2 ; add2 . B = 3 ; double result = add2 . GetResult (); Note: The properties in the class that extends IBinaryOperation are auto-implemented by the compiler and a backing field is automatically added (see #Automatic properties). Extending multiple interfaces Interfaces and classes are allowed to extend multiple interfaces. class MyClass : IInterfaceA , IInterfaceB { ... } Here is an interface that extends two interfaces. interface IInterfaceC : IInterfaceA , IInterfaceB { ... } Interfaces vs. abstract classes [ edit ] Interfaces and abstract classes are similar. The following describes some important differences: An abstract class may have member variables as well as non-abstract methods or properties. An interface cannot. A class or abstract class can only inherit from one class or abstract class. A class or abstract class may implement one or more interfaces. An interface can only extend other interfaces. An abstract class may have non-public methods and properties (also abstract ones). An interface can only have public members. An abstract class may have constants, static methods and static members. An interface cannot. An abstract class may have constructors. An interface cannot. Generics [ edit ] Generics (or parameterized types, parametric polymorphism) use type parameters, which make it possible to design classes and methods that do not specify the type used until the class or method is instantiated. The main advantage is that one can use generic type parameters to create classes and methods that can be used without incurring the cost of runtime casts or boxing operations, as shown here:[16] // Declare the generic class. public class GenericList < T > { void Add ( T input ) { } } class TestGenericList { private class ExampleClass { } static void Main () { // Declare a list of type int. var list1 = new GenericList < int > (); // Declare a list of type string. var list2 = new GenericList < string > (); // Declare a list of type ExampleClass. var list3 = new GenericList < ExampleClass > (); } } When compared with C++ templates, C# generics can provide enhanced safety, but also have somewhat limited capabilities.[17] For example, it is not possible to call arithmetic operators on a C# generic type.[18] Unlike C++ templates, .NET parameterized types are instantiated at runtime rather than by the compiler; hence they can be cross-language whereas C++ templates cannot. They support some features not supported directly by C++ templates such as type constraints on generic parameters by use of interfaces. On the other hand, C# does not support non-type generic parameters. Unlike generics in Java, .NET generics use reification to make parameterized types first-class objects in the Common Language Infrastructure (CLI) Virtual Machine, which allows for optimizations and preservation of the type information.[19] Using generics [ edit ] Generic classes [ edit ] Classes and structs can be generic. public class List < T > { ... public void Add ( T item ) { ... } } var list = new List < int > (); list . Add ( 6 ); list . Add ( 2 ); Generic interfaces [ edit ] interface IEnumerable < T > { ... } Generic delegates [ edit ] delegate R Func < T1 , T2 , R > ( T1 a1 , T2 a2 ); Generic methods [ edit ] public static T [] CombineArrays < T > ( T [] a , T [] b ) { T [] newArray = new T [ a . Length + b . Length ]; a . CopyTo ( newArray , 0 ); b . CopyTo ( newArray , a . Length ); return newArray ; } string [] a = new string [] { "a" , "b" , "c" }; string [] b = new string [] { "1" , "2" , "3" }; string [] c = CombineArrays ( a , b ); double [] da = new double [] { 1.2 , 2.17 , 3.141592 }; double [] db = new double [] { 4.44 , 5.6 , 6.02 }; double [] dc = CombineArrays ( da , db ); // c is a string array containing { "a", "b", "c", "1", "2", "3"} // dc is a double array containing { 1.2, 2.17, 3.141592, 4.44, 5.6, 6.02} Type-parameters are names used in place of concrete types when defining a new generic. They may be associated with classes or methods by placing the type parameter in angle brackets < > . When instantiating (or calling) a generic, one can then substitute a concrete type for the type-parameter one gave in its declaration. Type parameters may be constrained by use of the where keyword and a constraint specification, any of the six comma separated constraints may be used:[20] Constraint Explanation where T : struct type parameter must be a value type where T : class type parameter must be a reference type where T : new () type parameter must have a constructor with no parameters (must appear last) where T : < base_class > type parameter must inherit from < base_class > where T : < interface > type parameter must be, or must implement this interface where T : U naked type parameter constraint Covariance and contravariance [ edit ] Generic interfaces and delegates can have their type parameters marked as covariant or contravariant, using keywords out and in , respectively. These declarations are then respected for type conversions, both implicit and explicit, and both compile-time and run-time. For example, the existing interface IEnumerable<T> has been redefined as follows: interface IEnumerable < out T > { IEnumerator < T > GetEnumerator (); } Therefore, any class that implements IEnumerable<Derived> for some class Derived is also considered to be compatible with IEnumerable<Base> for all classes and interfaces Base that Derived extends, directly, or indirectly. In practice, it makes it possible to write code such as: void PrintAll ( IEnumerable < object > objects ) { foreach ( object o in objects ) { System . Console . WriteLine ( o ); } } IEnumerable < string > strings = new List < string > (); PrintAll ( strings ); // IEnumerable<string> is implicitly converted to IEnumerable<object> For contravariance, the existing interface IComparer<T> has been redefined as follows: public interface IComparer < in T > { int Compare ( T x , T y ); } Therefore, any class that implements IComparer<Base> for some class Base is also considered to be compatible with IComparer<Derived> for all classes and interfaces Derived that are extended from Base . It makes it possible to write code such as: IComparer < object > objectComparer = GetComparer (); IComparer < string > stringComparer = objectComparer ; Enumerators [ edit ] An enumerator is an iterator. Enumerators are typically obtained by calling the GetEnumerator() method of an object implementing the IEnumerable interface. Container classes typically implement this interface. However, the foreach statement in C# can operate on any object providing such a method, even if it doesn't implement IEnumerable . This interface was expanded into generic version in .NET 2.0. The following shows a simple use of iterators in C# 2.0: // explicit version IEnumerator < MyType > iter = list . GetEnumerator (); while ( iter . MoveNext ()) Console . WriteLine ( iter . Current ); // implicit version foreach ( MyType value in list ) Console . WriteLine ( value ); Generator functionality [ edit ] This is a feature of C# 2.0. The .NET 2.0 Framework allowed C# to introduce an iterator that provides generator functionality, using a yield return construct similar to yield in Python.[21] With a yield return , the function automatically keeps its state during the iteration. // Method that takes an iterable input (possibly an array) // and returns all even numbers. public static IEnumerable < int > GetEven ( IEnumerable < int > numbers ) { foreach ( int i in numbers ) { if ( i % 2 == 0 ) yield return i ; } } // using the method to output only even numbers from the array static void Main () { int [] numbers = { 1 , 2 , 3 , 4 , 5 , 6 }; foreach ( int i in GetEven ( numbers )) Console . WriteLine ( i ); //outputs 2, 4 and 6 } LINQ [ edit ] LINQ, short for Language Integrated Queries, is a .NET Framework feature which simplifies the handling of data. Mainly it adds support that allows the querying of arrays, collections, and databases. It also introduces binders, which makes it easier to access to databases and their data. Query syntax [ edit ] The LINQ query syntax was introduced in C# 3.0 and lets one write SQL-like queries in C#. var list = new List < int > { 2 , 7 , 1 , 3 , 9 }; var result = from i in list where i > 1 select i ; The statements are compiled into method calls, whereby almost only the names of the methods are specified. Which methods are ultimately used is determined by normal overload resolution. Thus, the result of the translation is affected by what symbols are in scope. What differs from SQL is that the from-statement comes first and not last as in SQL. This is because it seems more natural writing like this in C# [citation needed] and supports "Intellisense" (Code completion in the editor). Anonymous methods [ edit ] Anonymous methods, or in their present form more commonly referred to as "lambda expressions", is a feature which allows programmers to write inline closure-like functions in their code. There are various ways to create anonymous methods. Prior to C# 3.0 there was limited support by using delegates. Anonymous delegates [ edit ] This is a feature of C# 2.0. Anonymous delegates are functions pointers that hold anonymous methods. The purpose is to make it simpler to use delegates by simplifying the process of assigning the function. Instead of declaring a separate method in code the programmer can use the syntax to write the code inline and the compiler will then generate an anonymous function for it. Func < int , int > f = delegate ( int x ) { return x * 2 ; }; Lambda expressions [ edit ] This is a feature of C# 3.0. Lambda expressions provide a simple syntax for inline functions that are similar to closures. Functions with parameters infer the type of the parameters if other is not explicitly specified. // [arguments] => [method-body] // With parameters n => n == 2 ( a , b ) => a + b ( a , b ) => { a ++ ; return a + b ; } // With explicitly typed parameters ( int a , int b ) => a + b // No parameters () => return 0 // Assigning lambda to delegate Func < int , int , int > f = ( a , b ) => a + b ; Multi-statement lambdas have bodies enclosed by braces and inside of them code can be written like in standard methods. ( a , b ) => { a ++ ; return a + b ; } Lambda expressions can be passed as arguments directly in method calls similar to anonymous delegates but with a more aesthetic syntax. var list = stringList . Where ( n => n . Length > 2 ); Lambda expressions are essentially compiler-generated methods that are passed via delegates. These methods are reserved for the compiler only and can not be used in any other context. Extension methods [ edit ] This is a feature of C# 3.0. Extension methods are a form of syntactic sugar providing the illusion of adding new methods to the existing class outside its definition. In practice, an extension method is a static method that is callable as if it were an instance method; the receiver of the call is bound to the first parameter of the method, decorated with keyword this : public static class StringExtensions { public static string Left ( this string s , int n ) { return s . Substring ( 0 , n ); } } string s = "foo" ; s . Left ( 3 ); // same as StringExtensions.Left(s, 3); Local functions [ edit ] This is a feature of C# 7.0. Local functions can be defined in the body of another method, constructor or property's getter and setter. Such functions have access to all variables in the enclosing scope, including parent method local variables. They are in scope for the entire method, regardless of whether they're invoked before or after their declaration. Access modifiers (public, private, protected) cannot be used with local functions. Also they do not support function overloading. It means there cannot be two local functions in the same method with the same name even if the signatures don't overlap.[22] After a compilation, a local function is transformed into a private static method, but when defined it cannot be marked static.[23] In code example below, the Sum method is a local function inside Main method. So it can be used only inside its parent method Main: static void Main ( string [] args ) { int Sum ( int x , int y ) { return x + y ; } Console . WriteLine ( Sum ( 10 , 20 )); Console . ReadKey (); } Miscellaneous [ edit ] Closure blocks [ edit ] C# implements closure blocks by means of the using statement. The using statement accepts an expression which results in an object implementing IDisposable , and the compiler generates code that guarantees the object's disposal when the scope of the using -statement is exited. The using statement is syntactic sugar. It makes the code more readable than the equivalent try ... finally block. public void Foo () { using ( var bar = File . Open ( "Foo.txt" )) { // do some work throw new Exception (); // bar will still get properly disposed. } } Thread synchronization [ edit ] C# provides the lock statement, which is yet another example of beneficial syntactic sugar. It works by marking a block of code as a critical section by mutual exclusion of access to a provided object. Like the using statement, it works by the compiler generating a try ... finally block in its place. private static StreamWriter _writer ; public void ConcurrentMethod () { lock ( _writer ) { _writer . WriteLine ( "Line 1." ); _writer . WriteLine ( "Followed by line 2." ); } } Attributes [ edit ] Attributes are entities of data that are stored as metadata in the compiled assembly. An attribute can be added to types and members like properties and methods. Attributes can be used for better maintenance of preprocessor directives. [CompilerGenerated] public class $ AnonymousType $ 120 { [CompilerGenerated] public string Name { get ; set ; } } The .NET Framework comes with predefined attributes that can be used. Some of them serve an important role at runtime while some are just for syntactic decoration in code like CompilerGenerated . It does only mark that it is a compiler-generated element. Programmer-defined attributes can also be created. An attribute is essentially a class which inherits from the System.Attribute class. By convention, attribute classes end with "Attribute" in their name. This will not be required when using it. public class EdibleAttribute : Attribute { public EdibleAttribute () : base () { } public EdibleAttribute ( bool isNotPoisonous ) { this . IsPoisonous = ! isNotPoisonous ; } public bool IsPoisonous { get ; set ; } } Showing the attribute in use using the optional constructor parameters. [Edible(true)] public class Peach : Fruit { // Members if any } Preprocessor [ edit ] C# features "preprocessor directives"[24] (though it does not have an actual preprocessor) based on the C preprocessor that allow programmers to define symbols, but not macros. Conditionals such as #if , #endif , and #else are also provided. Directives such as #region give hints to editors for code folding. The #region block must be terminated with a #endregion directive. public class Foo { #region Constructors public Foo () {} public Foo ( int firstParam ) {} #endregion #region Methods public void IntBar ( int firstParam ) {} public void StrBar ( string firstParam ) {} public void BoolBar ( bool firstParam ) {} #endregion } C# utilizes a double slash ( // ) to indicate the rest of the line is a comment. public class Foo { // a comment public static void Bar ( int firstParam ) {} // Also a comment } Multi-line comments can be indicated by a starting slash/asterisk ( /* ) and ending asterisk/forward slash ( */ ). public class Foo { /* A multi-line comment */ public static void Bar ( int firstParam ) {} } Comments do not nest. These are two single comments: // Can put /* */ */ */ /* /* /* Can put /* /* /* but it ends with */ Single-line comments beginning with three slashes are used for XML documentation. This, however, is a convention used by Visual Studio and is not part of the language definition: /// <summary> /// This class is very classy. /// </summary> C#'s documentation comments[25] are similar to Java's Javadoc, but based on XML. Two methods of documentation are currently supported by the C# compiler. Single-line documentation comments, such as those commonly found in Visual Studio generated code, are indicated on a line beginning with /// . public class Foo { /// <summary>A summary of the method.</summary> /// <param name="firstParam">A description of the parameter.</param> /// <remarks>Remarks about the method.</remarks> public static void Bar ( int firstParam ) {} } Multi-line documentation comments, while defined in the version 1.0 language specification, were not supported until the .NET 1.1 release.[26] These comments are designated by a starting forward slash/asterisk/asterisk ( /** ) and ending asterisk/forward slash ( */ ). public class Foo { /** <summary>A summary of the method.</summary> * <param name="firstParam">A description of the parameter.</param> * <remarks>Remarks about the method.</remarks> */ public static void Bar ( int firstParam ) {} } There are some stringent criteria regarding white space and XML documentation when using the forward slash/asterisk/asterisk ( /** ) technique. This code block: /** * <summary> * A summary of the method.</summary>*/ produces a different XML comment than this code block: /** * <summary> A summary of the method.</summary>*/ Syntax for documentation comments and their XML markup is defined in a non-normative annex of the ECMA C# standard. The same standard also defines rules for processing of such comments, and their transformation to a plain XML document with precise rules for mapping of Common Language Infrastructure (CLI) identifiers to their related documentation elements. This allows any C# integrated development environment (IDE) or other development tool to find documentation for any symbol in the code in a certain well-defined way. Async-await syntax [ edit ] As of .NET Framework 4 there is a task library that makes it easier to write parallel and multi-threaded applications through tasks. C# 5.0 has native language support for asynchrony. Consider this code that takes advantage of the task library directly: public static class SomeAsyncCode { public static Task < XDocument > GetContentAsync () { var httpClient = new HttpClient (); return httpClient . GetStringAsync ( "https://www.contoso.com/" ). ContinueWith (( task ) => { string responseBodyAsText = task . Result ; return XDocument . Parse ( responseBodyAsText ); }); } } var t = SomeAsyncCode . GetContentAsync (). ContinueWith (( task ) => { var xmlDocument = task . Result ; }); t . Start (); Here is the same logic written in the async-await syntax: public static class SomeAsyncCode { public static async Task < XDocument > GetContentAsync () { var httpClient = new HttpClient (); string responseBodyAsText = await httpClient . GetStringAsync ( "https://www.contoso.com/" ); return XDocument . Parse ( responseBodyAsText ); } } var xmlDocument = await SomeAsyncCode . GetContentAsync (); // The Task will be started on call with await. Dialects [ edit ] Spec# is a dialect of C# that is developed in parallel with the standard implementation from Microsoft. It extends C# with specification language features and is a possible future feature to the C# language. It also adds syntax for the code contracts API that was introduced in .NET Framework 4.0. Spec# is being developed by Microsoft Research. This sample shows two of the basic structures that are used when adding contracts to code. static void Main ( string ! [] args ) requires args . Length > 0 { foreach ( string arg in args ) { } } ! is used to make a reference type non-nullable, e.g. it is not possible to set the value to null. This in contrast of nullable types which allow value types to be set as null. is used to make a reference type non-nullable, e.g. it is not possible to set the value to null. This in contrast of nullable types which allow value types to be set as null. requires indicates a condition that must be followed in the code. In this case the length of args is not allowed to be zero or less. Non-nullable types [ edit ] Spec# extends C# with non-nullable types that simply checks so the variables of nullable types that has been set as non-nullable are not null. If is null then an exception will be thrown. string ! input In use: public Test ( string ! input ) { ... } Preconditions [ edit ] Preconditions are checked before a method is executed. public Test ( int i ) requires i > 0 ; { this . i = i ; } Postconditions [ edit ] Postconditions are conditions that are ensured to be correct when a method has been executed. public void Increment () ensures i > 0 ; { i ++ ; } Checked exceptions [ edit ] Spec# adds checked exceptions like those in Java. public void DoSomething () throws SomeException ; // SomeException : ICheckedException { ... } Checked exceptions are problematic, because when a lower-level function adds a new exception type, the whole chain of methods using this method at some nested lower level must also change its contract. This violates the open/closed principle.[28] See also [ edit ]